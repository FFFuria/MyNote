#Dijkstra算法 #蚁群算法 #遗传算法 #动态规划算法 #A星算法 #D星Lite算法 #Floyd算法 #RRT算法 #RRT星算法 #InformRRT星
# Dijkstra算法
## 算法思想
### 主要思想
将节点分为两组后，一组为已求出最短路径的节点 另一组为未确定的，此后对未确定进行遍历，将最短距离节点纳入已知路径的节点
最后求得的总和即最短距离
![[file-20251104212314645.png|498]]
![[file-20251104212314641.png|498]]

## 大概流程
1）将字母节点转换为数字节点
![[file-20251104212314644.png|446]]

2）初始化节点
S只包含起点s；U包含s以外的所有节点

3）节点遍历后选择临近节点
从U中选出距离s最近的节点并将此节点加入到S当中，同时从U中移除该节点
![[file-20251104212314642.png]]
更新U中各节点与s的最短的那一个的距离（即与已选出来的节点的集合）
（比如步骤3中更新出来的F为2+4而不是3+6）
![[file-20251104212314638.png]]
*你肯定需要记录每次改变时，从哪个节点来的，才导致从起点到这一点的距离最小*

# 蚁群算法
## 算法思想
### 主要思想
通常蚂蚁在寻找目标点时会在路径上释放信息素，浓度越高则路径越短
而后续蚂蚁会以 **较大概率** 选择较高浓度信息素的路径进行觅食，从而造成信息素的积累
正反馈作用下，最后信息素会集中到最短路径上面 即最优解 
![[file-20251104212314621.png|376]]

### 算法精讲
![[file-20251104212314617.png|376]]
![[file-20251104212314619.png]]
 蚂蚁选择下一节点的概率依照公式
 蚂蚁无法返回上一个节点
 
 α：信息素重要程度银子 → 这条路径信息素浓度越大，越往这条路
 β：启发函数重要程度因子 → 启发函数 *（距离的倒数）*，越往这条路

#### 信息素的更新
![[file-20251104212314612.png]]
实时更新方便下一只蚂蚁的选择

*在不同模型当中，参数的更新不同*
*example.*
![[file-20251104212314609.png|611]]
*假设Q是100，Lk就是路径长度。套上公式Q/Lk。因为AB的路径最短，所以AB的信息素浓度是最高的。
ij应该是相邻城市，因为前面P就是基于相邻城市的*

### 算法框图
![[file-20251104212314608.png|403]]
#### 蚂蚁算法核心流程总结
1. **单只蚂蚁路径搜索**：蚂蚁初始阶段通过概率性随机选择节点的方式移动，一旦访问到终点（找到食物源），该蚂蚁即完成使命，其路径确定。
2. **多蚂蚁循环搜索**：第1只蚂蚁完成后，第2只及后续共m只蚂蚁均重复上述随机搜索至终点的过程，直至m只蚂蚁全部循环完毕。
3. **迭代与信息素更新**：
   - m只蚂蚁循环结束后，判断是否达到预设的最大迭代次数。
   - 若未达到，更新图中各路径的信息素，随后返回“多蚂蚁循环搜索”步骤，重复流程。
1. **核心循环结构**：算法包含两层循环，外层为“最大迭代次数”循环，内层为“m只蚂蚁搜索”循环。

# 遗传算法
* 选择
* 交叉
* 变异
## 算法模拟
### 种群初始化
**个体生成模拟种群**
1. 每行选择一个栅格
2. 判断栅格间是否连续
	判断公式：
	$D = \max\left\{\text{abs}(x^{i+1} - x^i), \text{abs}(y^{i+1} - y^i)\right\}$
	$y = \text{int}(N / G_{\text{size}}) + 1$
	$x = N \% Gsize + 1$
3. 不连续时插入新的栅格直到连续
	$x_{\text{new}} = \text{int}\left(\frac{x_{i+1} + x_i}{2}\right)$
	$y_{\text{new}} = \text{int}\left(\frac{y_{i+1} + y_i}{2}\right)$
![[file-20251104222849660.png|293]]
### 种群模拟
#### 种群选择
通过三角形的角度判断路径的顺滑度
	$d = \sum_{i=1}^{end-1} \sqrt{(x_{i+1} - x_i)^2 + (y_{i+1} - y_i)^2}$ 
	$fit_1 = 1/d$
	$fit_2 = \arccos\left(\frac{b^2 + c^2 - a^2}{2bc}\right)$
	$fit = a fit_1 + b fit_2$
	$p_i = \frac{fit_i}{\sum_{i=1}^{end} fit_i}$
#### 种群交叉
当产生交叉时，以交叉点进行路径的交换，生成新的个体
#### 种群变异
1. 随机选取两个栅格
2. 仿照种群初始化方法，栅格间生成路径


# 动态规划算法
## 算法思想
### 主要核心思想
将多阶段决策过程转化为一系列单阶段最优化问题 *（由美国数学家贝尔曼提出）*，核心逻辑为 “最优决策的子决策必最优”
各个阶段决策的选取，不是任意确定的，它依赖于当前命令的状态，也影响以后的发展。
![[file-20251104212314607 1.png|559]]
 *7个阶段，每个阶段选取最优状态并连接*

### 精讲
动态规划算法核心要素为“逆向寻优，正向求解”
具体逻辑如下：
1. **目标场景**：以寻找图中从A点到E点的最短路径为例。
2. **逆向寻优**：不按常规从起点（A点）逐步向终点（E点）探索，而是从最后一个阶段的状态（即终点E点）反向推导，寻找最优路径。 
3. **正向求解**：完成逆向寻优、确定最优路径后，再从起点（A点）出发，按正向顺序轻松还原出已确定的最优路径，此过程因前期寻优已完成而更简单。

*其他算法要么 “短视”（贪心）、要么 “低效”（暴力）、要么 “场景受限”（BFS），而动态规划的 “逆向寻优 + 正向求解” 本质是解决了两个核心问题：
1. **解决 “短视问题”**：贪心算法只看当前最优，而动态规划通过 “逆向推导”，从终点倒推每个阶段的选择，确保每个 “局部最优” 都能串联成 “全局最优”（依赖 “最优子结构” 性质）；
2. **解决 “低效问题”**：暴力搜索重复计算重叠路径，而动态规划通过 “存储子问题解”（如每个节点到终点的最短距离），将时间复杂度从 “指数级” 降到 “线性级”（依赖 “重叠子问题” 性质）；
3. **解决 “场景局限问题”**：BFS 仅适用于边权相等的图，而动态规划对边权（无负环）无限制，可用于更复杂的多阶段决策问题（如带权重的资源分配、时间规划等）。
![[file-20251104212314607.png|547]]

三层循环举例：
![[file-20251104212314605.png|290]]
**处理阶段 （第一层循环：stage=3）**
    - 阶段 3 有 4 个状态：D, E, F, G
        
    - 处理 D:
        
        - 可转移到 H 和 I
        - 计算 D→H: 3 + dp [4][H]= 5
        - 计算 D→I: 4 + dp [4][I]= 5
        - 取最小值：dp [3][D] = 5
    - 处理 E:
        
        - 可转移到 H 和 I
        - 计算 E→H: 2 + 2 = 4
        - 计算 E→I: 1 + 1 = 2
        - 取最小值：dp [3][E] = 2
    - (以此类推处理 F 和 G)

## 应用层面
* 两档变速器最优换挡规律
* 混合动力汽车最优能量管理
* 栅格地图最优路径搜索
实际应用中并非案例所示的简单场景，关键难题在于从后一阶段状态（如第四状态）向前一阶段状态（如第三状态）推导时，前一阶段的具体状态是事先未知的，增加了操作复杂性。

# A* 算法
 ## A* 算法
### 算法思想
#### 定位
静态路网中求解最短路径的最有效直接搜索方法
#### 主要思想
*结合了贪心算法和Dijkstra算法。*
1. **广度优先**：遍历搜索空间内每个节点，基于此的迪杰斯特拉算法能确保找到**全局最优路径**。
2. **贪心算法（深度优先思路）**：以当前搜索到的 “最小路径” 为目标，沿该路径持续深入搜索，存在两大局限：
    - 搜索结果**不一定是全局最优路径**；
    - 可能因深入方向遇到 “死节点”（参考 *蚁群算法* 案例），导致**无法找到目标节点**。
##### 优劣评估公式：
$f(n) = g(n) + h(n)$
![[file-20251104212314604.png|550]]
*`h(n)`是一个估计的代价，根据当前节点与目标节点的直线和，不考虑障碍物因为不知道障碍物*
#### 算法流程
##### 预处理
1. 地图栅格化成为一个个正方形，每个正方形为一个 **节点
2. 每个节点标注为 **可走** 与 **不可走**
3. 定义列表 **open list** 和 **close list** ，类似Dijkstra的 **U** 和 **S**，然后定义 **初始节点** 和 **目标节点**
4. 定义初始节点 **start note** 为 **父节点** ，周围八格为 **子节点** ，子节点归入 **open list** 当中，作为 **待考察对象** 
5. **单步移动代价计算方式**：采用 “曼哈顿计算方式”，模拟纽约曼哈顿井字格街区移动逻辑，仅允许横向或纵向移动。
* 横向 / 纵向移动 1 个节点，代价定义为 10（原示例为 1，后续调整）。
- 调整原因：若需计算斜向移动（如 A 到 D 节点），可通过等腰三角形斜边公式得约 1.4 的基础值，乘以 10 后得 14，避免小数计算，简化运算。
##### 继续搜索
1. 类似Dijstra算法，更新 **open list** 和 **close list** 
2. 忽略周围八格当中的 **障碍物节点** 和 **close list** 当中的节点
3. 检查处于 **open list** 当中的相邻节点是否为最优，*若否 不做操作

### 与Dijkstra的核心区别
### 核心逻辑差异：是否引入 “启发函数”
*这是两者最本质的区别，直接决定了搜索效率。
- **Dijkstra 算法**：只看 “已走的成本”
    它的路径优先级只由 `g(n)` 决定，`g(n)` 表示从**起点**到当前节点 `n` 已经花费的实际成本（比如距离、时间）。
    算法会优先扩展 “当前离起点最近” 的节点，不管这些节点离终点远不远，属于 “地毯式搜索”。
- **A * 算法**：结合 “已走成本 + 预估成本”
    它的路径优先级由 `f(n) = g(n) + h(n)` 决定，其中：
    - `g(n)`：和 Dijkstra 一样，是起点到当前节点的实际成本；
    - `h(n)`：**启发函数**，是当前节点 `n` 到**终点**的 “预估成本”（比如直线距离，只算大概，不算实际路径）。
*算法会优先扩展 “已走成本 + 预估成本总和最小” 的节点，相当于 “朝着终点方向找最近的路”。

## D* Lite算法
>动态的A* 算法，动态避障 融合了 LPA_算法的增量搜索思想与 D * 算法的反向搜索思想
### 算法思想
从目标点向起点反向构建路径，核心通过维护节点的
`g`值（到终点的实际代价）`rhs`值（基于后继节点的最小代价估计）和`km`参数（起点变化时的启发值补偿）
实现动态环境下的局部增量更新。当环境变化时，仅需更新受影响的节点，无需全图重算。
### 算法流程
#### 1. 初始化阶段（首次路径规划）
- **步骤 1：初始化参数**
    所有节点的`g`和`rhs`设为无穷大，目标点的`rhs`设为 0，计算其`key`值（由`k1 = rhs + h`、`k2 = min(rhs, g)`组成，`h`为启发式函数），并加入优先队列。
- **步骤 2：节点扩展与路径构建**
    循环从优先队列中取出`key`最小的节点，更新其相邻节点的`rhs`和`g`值：
    - 若节点`g`不等于`rhs`，标记为**局部不一致**并重新计算`key`；
    - 若节点`g`大于`rhs`，更新`g = rhs`（局部过一致 → 一致）；
    - 若节点`g`小于`rhs`，设`g = 无穷大`（局部欠一致 → 过一致），并触发后继节点的更新；
        直到起点的`g`等于`rhs`，路径构建完成。
#### 2. 动态更新阶段（环境变化或起点移动时）
- **步骤 1：检测环境变化**
    若发现障碍物或路径代价变化，更新对应边的代价，并调整相关节点的`rhs`值。
- **步骤 2：增量式重规划**
    计算`km`（起点移动的启发值补偿），更新受影响节点的`key`，再重复 “节点扩展 - 更新`g/rhs`” 的过程，直到优先队列中节点的`key`不小于当前起点的`key`，新路径生成。

# Floyd算法
*求任意两点最短路径*
## 邻接矩阵
![[file-20251104212314603.png|676]]
*2到1没有边，于是无穷；自己到自己标注为0*
## 核心思想
*实际上就是依次将每个点作为中间点，然后去做更新*
### 流程
**1.定义两个数组**
*右上角标-1表示现在是初始状态*
![[file-20251104212314600.png|357]]
> 有边 → 多少到多少共几条边
> 自己 → 自己到自己为-1
> 无边 → -1

对于Path（填写的是 **前置点** ）
*从“2”到“0”，前置点是“2”*
*0->2在D数组里面是13，说明走的是0->2这条边，起点是0，所以Path数组里面<0，2>填0*

**2.依次将每个点作为中间点进行更新**
*D(0)中的0可以理解为经过的点可以包含0，而不是一定包含0，同理D（1）的意思是过程点可以包含【0,1】的点，D(k)就是可以包含【0-k】之间的过程点，这是一个动态规划的过程，后续包含前面*
![[file-20251104213218819.png|357]]
即选取右上标作为必须经过的中节点后进行计算，若 **距离更短** 则更新表格，否则不更新
*tips.角标所在那一列和那一行无需更新*

**3.循环上述操作**
最后获得如下表：

**任意两点最短路径表**
![[file-20251104213645757.png|357]]
 Path表从终点查阅表格获得前一个点，再继续查前一个点的再前一个点

# RRT算法
## RRT算法
*快速拓展随机树算法*
*不基于栅格，而是以一棵树进行对外拓展*
### 算法流程
**1.随机锚定方向**
随机锚定方向后，以最近节点为开始节点后依固定步长进行生长

**2.if有障碍物**
![[file-20251104220515960.png|205]]
放弃此次生长

**3.停止循环**
因为准确命中终点较难，所以会设立一定半径充当结束范围
![[file-20251104220808518.png|205]]
*tips.实际应用中会设定一定概率往终点进行方向锚定*
## RRT* 算法
*引入：在一定范围内选择新的父节点*
### 改进图示
![[file-20251104221624232.png|298]]
![[file-20251104221430375.png|298]]
![[file-20251104221503140.png|298]]

## InformedRRT* 
*设立一个采样范围，在采样范围内进行收缩式生长*
![[file-20251104221857398.png|558]]
![[file-20251104223927273.png|558]]
